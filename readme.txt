作者发现，在使用半张量积对玩家的策略相乘从而表示成局势时，状态空间中的数字按大小排列等价于将局势按字典序排列
举个栗子
    有两个玩家，每个玩家两个策略，令他们为1，2
    此时，所有局势按字典序从小到大排列为11，12，21，22
    而他们相当于状态空间中的1，2，3，4
因此，作者在这里跳过了半张量积中的换位，降幂等算子，直接利用状态空间中的状态(数字)对应的局势信息，
根据设定的SUR，来计算下一时刻将要跳转的状态。
Game.py的核心思路就是这样，
至于其它的几个模块，主要是一些辅助工作，如画出状态轨迹图，利用BFS寻找最短路径，以及生成随机序列模拟演化过程等


Game.py 是博弈模型构建，然后最后生成各个异步矩阵，虽然被设计用于带记忆的，但其实只要在参数设置时把记忆长度改为1
就能够用于普通的一步记忆

Draft.py 是用来画某一个特定更新序列下的状态轨迹图

ControllerGenerator.py 是用来生成一个最佳的异步更新序列，并基于这个更新序列给出状态转移图

AverageStable.py 生成随机序列，并计算随机更新到达不懂点的最短长度，平均长度等